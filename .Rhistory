# Corrélations simples et affichage graphique (base R)
vars <- names(data_numeric)[-ncol(data_numeric)]
cors <- sapply(vars, function(v) cor(data_numeric$Happiness, data_numeric[[v]]))
# trier par valeur (pour barplot horizontal)
names(cors) = nomsdevar
cors_sorted <- sort(cors)
par(mar = c(5, 8, 4, 2))
barplot(cors_sorted,
horiz = TRUE, las = 1,
# bicolor
col = ifelse(cors_sorted > 0, "lightblue", "salmon1"),
main = "Corrélations avec l'indice de bonheur",
)
abline(v = 0, lty = 2, col = "grey40")
par(mar = c(5, 4, 4, 2) + 0.1)
names(data_numeric)[-ncol(data_numeric)]
# Corrélations simples et affichage graphique (base R)
vars <- names(data_numeric)[-ncol(data_numeric)]
cors <- sapply(vars, function(v) cor(data_numeric$Happiness, data_numeric[[v]]))
# trier par valeur (pour barplot horizontal)
names(cors) = nomsdevar
cors_sorted <- sort(cors)
par(mar = c(5, 8, 4, 2))
barplot(cors_sorted,
horiz = TRUE, las = 1,
# bicolor
col = ifelse(cors_sorted > 0, "lightblue", "salmon1"),
main = "Corrélations avec l'indice de bonheur",
)
abline(v = 0, lty = 2, col = "grey40")
par(mar = c(5, 4, 4, 2) + 0.1)
# Corrélations simples et affichage graphique (base R)
vars <- names(data_numeric)[-ncol(data_numeric)]
cors <- sapply(vars, function(v) cor(data_numeric$Happiness, data_numeric[[v]]))
# trier par valeur (pour barplot horizontal)
names(cors) = nomsdevar
cors_sorted <- sort(cors)
par(mar = c(5, 8, 4, 2))
barplot(cors_sorted,
horiz = TRUE, las = 1,
# bicolor
col = ifelse(cors_sorted > 0, "lightblue", "salmon1"),
main = "Corrélations avec l'indice de bonheur",
)
abline(v = 0, lty = 2, col = "grey40")
par(mar = c(5, 4, 4, 2) + 0.1)
# Corrélations simples et affichage graphique (base R)
vars <- names(data_numeric)[-ncol(data_numeric)]
cors <- sapply(vars, function(v) cor(data_numeric$Happiness, data_numeric[[v]]))
# trier par valeur (pour barplot horizontal)
names(cors) = nomsdevar
cors_sorted <- sort(cors)
par(mar = c(5, 8, 4, 2))
barplot(cors_sorted,
horiz = TRUE, las = 1,
# bicolor
col = ifelse(cors_sorted > 0, "lightblue", "salmon1"),
main = "Corrélations avec l'indice de bonheur",
)
abline(v = 0, lty = 2, col = "grey40")
par(mar = c(5, 4, 4, 2) + 0.1)
# Tracé des graphes de points et de la linéarité
scatter_plots <- list()
for (i in 2:11) {
p <- ggplot(data, aes_string(x = data[[i]], y = "Happiness")) +
geom_point() +
geom_smooth(method = lm, color = "salmon1", fill = "lightblue", se = TRUE) +
labs(x = nomsdevar[i-1], y = "Happiness") +
theme_minimal()
scatter_plots[[i - 1]] <- p
}
# nombre de colonnes voulu
ncol_plot <- 3
do.call(grid.arrange, c(scatter_plots, ncol = 1))
# colnames(data)[i]
# Tracé des graphes de points et de la linéarité
scatter_plots <- list()
for (i in 2:11) {
p <- ggplot(data, aes_string(x = data[[i]], y = "Happiness")) +
geom_point() +
geom_smooth(method = lm, color = "salmon1", fill = "lightblue", se = TRUE) +
labs(x = nomsdevar[i-1], y = "Happiness") +
theme_minimal()
scatter_plots[[i - 1]] <- p
}
# nombre de colonnes voulu
ncol_plot <- 3
# Tracé des graphes de points et de la linéarité
scatter_plots <- list()
for (i in 2:11) {
p <- ggplot(data, aes_string(x = data[[i]], y = "Happiness")) +
geom_point() +
geom_smooth(method = lm, color = "salmon1", fill = "lightblue", se = TRUE) +
labs(x = nomsdevar[i-1], y = "Happiness") +
theme_minimal()
scatter_plots[[i - 1]] <- p
}
# nombre de colonnes voulu
ncol_plot <- 3
# Tracé des graphes de points et de la linéarité
scatter_plots <- list()
for (i in 2:11) {
p <- ggplot(data, aes_string(x = data[[i]], y = "Happiness")) +
geom_point() +
geom_smooth(method = lm, color = "salmon1", fill = "lightblue", se = TRUE) +
labs(x = nomsdevar[i-1], y = "Happiness") +
theme_minimal()
scatter_plots[[i - 1]] <- p
}
do.call(grid.arrange, c(scatter_plots[c(3)], ncol = 1))
# Tracé des graphes de points et de la linéarité
scatter_plots <- list()
for (i in 2:11) {
p <- ggplot(data, aes_string(x = data[[i]], y = "Happiness")) +
geom_point() +
geom_smooth(method = lm, color = "salmon1", fill = "lightblue", se = TRUE) +
labs(x = nomsdevar[i-1], y = "Happiness") +
theme_minimal()
scatter_plots[[i - 1]] <- p
}
do.call(grid.arrange, c(scatter_plots[c(3)], ncol = 1))
# Tracé des graphes de points et de la linéarité
scatter_plots <- list()
for (i in 2:11) {
p <- ggplot(data, aes_string(x = data[[i]], y = "Happiness")) +
geom_point() +
geom_smooth(method = lm, color = "salmon1", fill = "lightblue", se = TRUE) +
labs(x = nomsdevar[i-1], y = "Happiness") +
theme_minimal()
scatter_plots[[i - 1]] <- p
}
do.call(grid.arrange, c(scatter_plots[c(3)], ncol = 1))
# Corrélations simples et affichage graphique (base R)
vars <- names(data_numeric)[-ncol(data_numeric)]
cors <- sapply(vars, function(v) cor(data_numeric$Happiness, data_numeric[[v]]))
# trier par valeur (pour barplot horizontal)
names(cors) = nomsdevar
cors_sorted <- sort(cors)
par(mar = c(5, 8, 4, 2))
barplot(cors_sorted,
horiz = TRUE, las = 1,
# bicolor
col = ifelse(cors_sorted > 0, "lightblue", "salmon1"),
main = "Corrélations avec l'indice de bonheur",
)
abline(v = 0, lty = 2, col = "grey40")
par(mar = c(5, 4, 4, 2) + 0.1)
data_PIB_log <- data
data_PIB_log$GDP_per_Capita <- log(data_PIB_log$GDP_per_Capita)
PIBplot <- ggplot(data_PIB_log, aes_string(x = "GDP_per_Capita", y = "Happiness")) +
geom_point(color = "blue") +
geom_smooth(method = lm, color = "salmon1", fill = "lightblue", se = TRUE) +
labs(x = "Logarithme du PIB par habitant", y = "Happiness") +
theme_minimal()
data_KWH_log <- data
data_KWH_log$KWH_pp_pc <- log(data_KWH_log$KWH_pp_pc)
KWHplot <- ggplot(data_KWH_log, aes_string(x = "KWH_pp_pc", y = "Happiness")) +
geom_point(color = "blue") +
geom_smooth(method = lm, color = "salmon1", fill = "lightblue", se = TRUE) +
labs(x = "Logarithme de la consommmation énergétique", y = "Happiness") +
theme_minimal()
data_migration <- data
data_migration$Net_Migration <- log(data_migration$Net_Migration)
migrationplot <- ggplot(data_migration, aes_string(x = "Net_Migration", y = "Happiness")) +
geom_point() +
geom_smooth(method = lm, color = "salmon1", fill = "lightblue", se = TRUE) +
labs(x = "Logarithme de la migration", y = "Happiness") +
theme_minimal()
logplots <- list(PIBplot, KWHplot, migrationplot)
do.call(grid.arrange, c(scatter_plots[c(2,7)],logplots[c(1,2)], ncol = 2))
data_ss_singapour <- data[-which(data$Code == "SGP"), ]
sspopplot <- ggplot(data_ss_singapour, aes_string(x = "Population_Density", y = "Happiness")) +
geom_point(color = "blue") +
geom_smooth(method = lm, color = "salmon1", fill = "lightblue", se = TRUE) +
labs(x = "Sans Singapour", y = "Happiness") +
theme_minimal()
data_ss_somalie <- data[-which(data$Code == "SOM"), ]
ssschoolplot <- ggplot(data_ss_somalie, aes_string(x = "Primary_School_Enrollment", y = "Happiness")) +
geom_point(color = "blue") +
geom_smooth(method = lm, color = "salmon1", fill = "lightblue", se = TRUE) +
labs(x = "Sans la Somalie", y = "Happiness") +
theme_minimal()
data_ss_pak_usa <- data[-which(data$Code == "PAK" | data$Code == "USA"), ]
ssmigrationplot <- ggplot(data_ss_pak_usa, aes_string(x = "Net_Migration", y = "Happiness")) +
geom_point(color = "blue") +
geom_smooth(method = lm, color = "salmon1", fill = "lightblue", se = TRUE) +
labs(x = "Sans les EU ni le Pakistan", y = "Happiness") +
theme_minimal()
outlierplots <- list(ssmigrationplot, sspopplot, ssschoolplot)
do.call(grid.arrange, c(c(scatter_plots[c(4,6,10)],outlierplots), ncol = 3))
library(sf)
library(tidyverse)
library(dplyr)
library(ggplot2)
commune = read.csv('MOBILITE.csv', sep = ';')
setwd("C:/Users/dejaj/OneDrive/Bureau/Données data challenge")
commune = read.csv('MOBILITE.csv', sep = ';')
library(sf)
library(tidyverse)
library(dplyr)
library(ggplot2)
setwd("C:/Users/dejaj/OneDrive/Bureau/rennesdatachallenge2026")
commune = read.csv('MOBILITE.csv', sep = ';')
View(commune)
code_communes = commune[,1]
code_communes = as.vector(code_communes)
code_communes
View(code_communes)
commune_sf <- commune_sf |>
mutate(communes_etudiees = code %in% commune[,1])
commune_sf = read_sf('communes-version-simplifiee.geojson')
commune_sf <- commune_sf |>
mutate(communes_etudiees = code %in% commune[,1])
plot(st_geometry(commune_sf), col = "lightblue", border = "grey")
# --- 2. Visualisation avec ggplot2 ---
ggplot(commune_sf) +
geom_sf(fill = "darkgrey", color = "darkgrey", size = 0.1) +
ggtitle("Carte des communes de France") +
theme_minimal()
# --- 3. Carte avec communes sélectionnées en rouge ---
ggplot(objet_sf) +
geom_sf(aes(fill = communes_etudiees), color = "grey40", size = 0.1) +
scale_fill_manual(
values = c("FALSE" = "lightgrey", "TRUE" = "red"),
name = "Sélection"
) +
ggtitle("Communes sélectionnées en rouge") +
theme_minimal()
# --- 3. Carte avec communes sélectionnées en rouge ---
ggplot(commune_sf) +
geom_sf(aes(fill = communes_etudiees), color = "grey40", size = 0.1) +
scale_fill_manual(
values = c("FALSE" = "lightgrey", "TRUE" = "red"),
name = "Sélection"
) +
ggtitle("Communes sélectionnées en rouge") +
theme_minimal()
# --- 3. Carte avec communes sélectionnées en rouge ---
ggplot(commune_sf) +
geom_sf(aes(fill = communes_etudiees), color = "lightgrey", size = 0.1) +
scale_fill_manual(
values = c("FALSE" = "lightgrey", "TRUE" = "red"),
name = "Sélection"
) +
ggtitle("Communes où vivent des travailleurs du CHU") +
theme_minimal()
library(sf)
library(tidyverse)
library(dplyr)
library(ggplot2)
commune = read.csv('MOBILITE.csv', sep = ';')
View(commune)
commune_sf = read_sf('communes-version-simplifiee.geojson')
commune_sf <- commune_sf |>
mutate(communes_etudiees = code %in% commune[,1])
# Afficher un résumé des données
print(commune_sf)
plot(st_geometry(commune_sf), col = "lightblue", border = "grey")
# --- 2. Visualisation avec ggplot2 ---
ggplot(commune_sf) +
geom_sf(fill = "darkgrey", color = "darkgrey", size = 0.1) +
ggtitle("Carte des communes de France") +
theme_minimal()
# --- 3. Carte avec communes sélectionnées en rouge ---
ggplot(commune_sf) +
geom_sf(aes(fill = communes_etudiees), color = "lightgrey", size = 0.1) +
scale_fill_manual(
values = c("FALSE" = "lightgrey", "TRUE" = "red"),
name = "Sélection"
) +
ggtitle("Communes où vivent des travailleurs du CHU") +
theme_minimal()
install.packages('leaflet')
library(leaflet)
library(shiny)
ui <- fluidPage(
titlePanel("Carte des salaires par ville"),
sidebarLayout(
sidebarPanel(
radioButtons(
"type_salaire",
"Type de salaire",
choices = c("Théorique" = "pred", "Observé" = "obs"),
selected = "pred"
)
),
mainPanel(
leafletOutput("map", height = 650)
)
)
)
library(shiny)
#install.packages('leaflet')
#install.packages('sf')
install.packages('shiny')
library(shiny)
# --- Carte avec communes sélectionnées en rouge ---
ggplot(commune_sf) +
geom_sf(aes(fill = communes_etudiees), color = "lightgrey", size = 0.1) +
scale_fill_manual(
values = c("FALSE" = "lightgrey", "TRUE" = "red"),
name = "Sélection"
) +
ggtitle("Communes où vivent des travailleurs du CHU") +
theme_minimal()
ui <- fluidPage(
titlePanel("Carte des salaires par ville"),
sidebarLayout(
sidebarPanel(
radioButtons(
"type_salaire",
"Type de salaire",
choices = c("Théorique" = "pred", "Observé" = "obs"),
selected = "pred"
)
),
mainPanel(
leafletOutput("map", height = 650)
)
)
)
# -------------------- SERVER --------------------
server <- function(input, output, session) {
# Reactive pour créer la colonne salaire_affiche
data_react <- reactive({
req(data_final)
df <- data_final %>%
mutate(
salaire_affiche = if (input$type_salaire == "pred") {
salaire_pred
} else {
Salaire_mensuel
}
)
df
})
# Render Leaflet
output$map <- renderLeaflet({
df <- data_react()
# Palette de couleur selon le salaire
pal <- colorNumeric(
palette = "viridis",
domain = df$salaire_affiche
)
leaflet(df) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(
lng = ~longitude,
lat = ~latitude,
radius = ~0.005*(salaire_affiche), # taille proportionnelle
fillColor = ~pal(salaire_affiche),
fillOpacity = 0.8,
stroke = FALSE,
label = ~paste0(city, " : ", round(salaire_affiche, 0), " €")
) %>%
addLegend(
pal = pal,
values = ~salaire_affiche,
title = ifelse(
input$type_salaire == "pred",
"Salaire théorique (€)",
"Salaire observé (€)"
)
)
})
}
data_final<-read.csv("carte_termine.csv",sep=",",dec=".")
ui <- fluidPage(
titlePanel("Carte des salaires par ville"),
sidebarLayout(
sidebarPanel(
radioButtons(
"type_salaire",
"Type de salaire",
choices = c("Théorique" = "pred", "Observé" = "obs"),
selected = "pred"
)
),
mainPanel(
leafletOutput("map", height = 650)
)
)
)
# -------------------- SERVER --------------------
server <- function(input, output, session) {
# Reactive pour créer la colonne salaire_affiche
data_react <- reactive({
req(data_final)
df <- data_final %>%
mutate(
salaire_affiche = if (input$type_salaire == "pred") {
salaire_pred
} else {
Salaire_mensuel
}
)
df
})
# Render Leaflet
output$map <- renderLeaflet({
df <- data_react()
# Palette de couleur selon le salaire
pal <- colorNumeric(
palette = "viridis",
domain = df$salaire_affiche
)
leaflet(df) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(
lng = ~longitude,
lat = ~latitude,
radius = ~0.005*(salaire_affiche), # taille proportionnelle
fillColor = ~pal(salaire_affiche),
fillOpacity = 0.8,
stroke = FALSE,
label = ~paste0(city, " : ", round(salaire_affiche, 0), " €")
) %>%
addLegend(
pal = pal,
values = ~salaire_affiche,
title = ifelse(
input$type_salaire == "pred",
"Salaire théorique (€)",
"Salaire observé (€)"
)
)
})
}
shinyApp(ui, server)
View(commune_sf[[3]][[1]])
centre_gravite_sf <- function(obj_sf) {
st_centroid(st_union(obj_sf))
}
centre_gravite_sf(commune_sf$geometry[1])
commune_sf$geometry[1]
commune_sf$geometry[1]
print(commune_sf$geometry[1])
centre_gravite_sf <- function(obj_sf) {
st_centroid(st_union(obj_sf))
}
print(commune_sf$geometry[1])
print(centre_gravite_sf(commune_sf$geometry[1]))
View(centre_gravite_sf(commune_sf$geometry[1]))
commune_sf$geometry[1]
centre_gravite_sf(commune_sf$geometry[1])
commune_sf <- commune_sf |>
mutate(centre_gravite = centre_gravite_sf(geometry))
commune_sf <- commune_sf |>
mutate(centre_gravite = centre_gravite_sf(commune_sf$geometry))
library(stringr)
commune_sf <- commune_sf %>%
mutate(
longitude = as.numeric(str_extract(geom, "(?<=POINT \\()[^ ]+")),
latitude  = as.numeric(str_extract(geom, "(?<= )[0-9.-]+(?=\\))"))
)
commune_sf <- commune_sf %>%
mutate(
coords = gsub("POINT \\(|\\)", "", centre_gravite),
lng = as.numeric(sub(" .*", "", coords)),
lat  = as.numeric(sub(".* ", "", coords))
) %>%
select(-coords)
centre_gravite_sf(commune_sf$geometry))
centre_gravite_sf(commune_sf$geometry)
x  =centre_gravite_sf(commune_sf$geometry)
x
x
x =centre_gravite_sf(commune_sf$geometry[1])
x
x =centre_gravite_sf(commune_sf$geometry[2])
x
commune_sf$centre_gravite = centre_gravite_sf(commune_sf$geometry)
for (x in 1:len(commune_sf$geometry)) {
commune_sf$centre_gravite[i] = centre_gravite_sf(commune_sf$geometry[i])
}
for (x in 1:length(commune_sf$geometry)) {
commune_sf$centre_gravite[i] = centre_gravite_sf(commune_sf$geometry[i])
}
for (x in 1:length(commune_sf$geometry)) {
commune_sf$centre_gravite[i] = centre_gravite_sf(commune_sf$geometry[i])
}
length(commune_sf$geometry)
for (x in 1:length(commune_sf$geometry)) {
commune_sf$centre_gravite[i] = centre_gravite_sf(commune_sf$geometry[i])
}
length(commune_sf$geometry)
for (x in 1:10) {
print(x)
}
for (x in 1:12) {
commune_sf$centre_gravite[i] = centre_gravite_sf(commune_sf$geometry[i])
}
commune_sf <- commune_sf |>
library(sf)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(leaflet)
library(shiny)
library(dplyr)
library(stringr)
commune_sf <- commune_sf |>
mutate(centre_gravite = st_centroid(st_union(commune_sf$geometry)))
length(commune_sf$geometry)
for (x in 1:length(commune_sf$geometry) ) {
commune_sf$centre_gravite[i] = centre_gravite_sf(commune_sf$geometry[i])
}
centre_gravite_sf <- function(obj_sf) {
st_centroid(st_union(obj_sf))
}
commune_sf <- commune_sf |>
mutate(centre_gravite = st_centroid(st_union(commune_sf$geometry)))
